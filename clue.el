;;; clue.el --- Connecting clues while reading code -*- lexical-binding: t -*-

;; Copyright (C) 2020 Hao WANG

;; Author: Hao WANG <amaikinono@gmail.com>
;; Maintainer: Hao WANG <amaikinono@gmail.com>
;; Created: 08 Nov 2020
;; Keywords: convenience, tools
;; Homepage: https://github.com/AmaiKinono/clue
;; Version: 0

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License
;; as published by the Free Software Foundation; either version 3
;; of the License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program. If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;;; Code:

;; To see the outline of this file, run M-x outline-minor-mode and
;; then press C-c @ C-t. To also show the top-level functions and
;; variable declarations in each section, run M-x occur with the
;; following query: ^;;;;* \|^(

;;;; Libraries

(require 'subr-x)

;;;; User options

(defgroup clue nil
  "Connecting clues while reading code."
  :group 'convenience
  :group 'tools
  :prefix "clue-"
  :link '(url-link "https://github.com/AmaiKinono/clue"))

(defcustom clue-keymap
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "RET") 'clue-follow-link)
    (define-key map (kbd "<mouse-1>") 'clue-follow-link)
    map)
  "Keymap that's enabled on links."
  :type 'keymap)

;;;; Internals

(defvar clue--link-regexp
  ;; generated by (rx "#[" (zero-or-more (not (or "[" "]"))) "]")
  "#\\[[^][]*]"
  "Regexp to match links.")

(defvar clue--search-limit 50000
  "The limit of chars to go when searching for a location.")

;; Suppress the byte-compile warning.
(defvar clue-mode nil
  "Non-nil if Clue mode is enabled.
Use the command `clue-mode' to change this variable.")

(defvar clue--copied-link nil
  "Recent copied location.")

;;;;; Font lock.

(defun clue--unfontify (beg end)
  "Remove fontification of links between BEG and END."
  (dolist (ov (overlays-in beg end))
    (when (overlay-get ov 'clue-link-p)
      (delete-overlay ov))))

(defun clue--fontify (beg end)
  "Fontify the links between BEG and END."
  (save-excursion
    (goto-char beg)
    (while (re-search-forward clue--link-regexp end t)
      (let* ((b (match-beginning 0))
             (e (match-end 0))
             ov)
        (setq ov (make-overlay b e))
        (overlay-put ov 'clue-link-p t)
        (overlay-put ov 'face 'button)
        (overlay-put ov 'mouse-face 'link)
        (overlay-put ov 'evaporate t)
        (overlay-put ov 'keymap clue-keymap)))))

(defun clue--refontify (beg end)
  "Refontify the links between BEG and END.
This is for use with jit-lock fontification, so the region to
refontify includes the two logical lines including BEG and END,
to prevent miss caused by line truncation inside the clues."
  (let ((beg (save-excursion (goto-char beg)
                             (line-beginning-position)))
        (end (save-excursion (goto-char end)
                             (line-end-position))))
    (clue--unfontify beg end)
    (clue--fontify beg end)))

;;;;; Generate links.

(defun clue--after-comment-p ()
  "Non-nil if the char before point is inside a comment.

Returns nil when at the beginning of a line.  This depends on
font lock mode."
  ;; NOTE: `syntax-ppss' is not always reliable, e.g. inside the comment
  ;; delimiter. I also heard it's unuseable in some major modes like web-mode.
  (if (bolp) nil
    (let ((pos-faces (get-text-property (1- (point)) 'face)))
      (unless (listp pos-faces)
        (setq pos-faces (list pos-faces)))
      (cl-intersection '(font-lock-comment-face
                         font-lock-comment-delimiter-face)
                       pos-faces))))

(defun clue--line-at-point ()
  "Return the line content at point.
But without starting/trailing whitespaces, and maybe comments.
See the implementation for details."
  (let ((beg (line-beginning-position))
        end)
    (save-excursion
      (end-of-line)
      (while (clue--after-comment-p)
        (backward-char))
      (setq end (point)))
    ;; If there are nothing other than the comment and whitespaces in the line,
    ;; we have to keep the comment.
    (when (string-match "^[ \t]*$" (buffer-substring-no-properties
                                    beg end))
      (setq end (line-end-position)))
    (string-trim (buffer-substring-no-properties beg end))))

;;;;; Follow links.

(defvar-local clue--location-alist nil
  "An alist of link title - locations in current buffer.")

(defun clue--link-title-at-point ()
  "Get link title at point."
  (let ((beg (or
              (save-excursion
                (re-search-backward "#\\[" (line-beginning-position) 'noerror))
              (when (and (not (bolp))
                         (eq (char-before) ?#)
                         (eq (char-after) ?\[))
                (1- (point)))))
        (end (save-excursion
               (re-search-forward "\\]" (line-end-position) 'noerror))))
    (when (and beg end)
      (buffer-substring-no-properties (+ beg 2) (1- end)))))

(defun clue--find-nearest-regexp
    (regexp &optional limit case-fold)
  "Find the nearest occurence of REGEXP from current position.
By \"nearar\" we mean there are fewer lines between current
position and the occurence.

This goes to the beginning of line position of the occurence, and
returns the position there.  If it's not found, return nil and
don't go anywhere.

When LIMIT is non-nil, it's the limit of chars that the search
goes.  CASE-FOLD decides case-sensitivity."
  (let ((start (line-beginning-position))
        (case-fold-search case-fold)
        after after-lines
        before before-lines)
    (save-excursion
      (beginning-of-line)
      (when (re-search-forward
             regexp (when limit (+ start limit)) t)
        (beginning-of-line)
        (setq after (point))
        (setq after-lines (count-lines start after))))
    (unless (and after (<= after-lines 1))
      (save-excursion
        (beginning-of-line)
        (when (re-search-backward
               regexp (when limit (- start limit)) t)
          (beginning-of-line)
          (setq before (point))
          (setq before-lines (count-lines before start)))))
    (cond
     ((and after before)
      (goto-char (if (< before-lines after-lines) before after)))
     ((or after before)
      (goto-char (or after before))))))

(defun clue--goto-location (location)
  "Goto LOCATION."
  (pcase-let ((`(,file ,line ,str) location))
    (unless (file-exists-p file)
      (user-error "File %s doesn't exist" file))
    (pop-to-buffer (find-file-noselect file))
    (beginning-of-line)
    (forward-line (1- line))
    (or (clue--find-nearest-regexp
         (concat "^[ \t]*" (regexp-quote str))
         clue--search-limit nil)
        (clue--find-nearest-regexp
         (concat "^[ \t]*" (regexp-quote str))
         clue--search-limit 'case-fold))))

;;;; Commands

(defun clue-copy ()
  "Copy the location of current line, or the link under point."
  ;; TODO: copy link
  (interactive)
  (let ((file (or (buffer-file-name)
                  (user-error "Buffer is not visiting a file"))))
    (setq clue--copied-link
          (cons nil
                (list file
                      (line-number-at-pos)
                      (clue--line-at-point))))))

(defun clue-paste ()
  "Paste the copied link."
  (interactive)
  (unless clue--copied-link
    (user-error "The clipboard is empty"))
  (unless clue-mode
    (clue-mode))
  (let* ((link clue--copied-link)
         (title (or (car link)
                    ;; TODO: Reject input that has brackets.
                    (read-string "Link title: "
                                 (concat (cadr link) ": ")))))
    (insert "#[" title "]")
    (setf (alist-get title clue--location-alist nil nil #'equal)
          (cdr link))))

(defun clue-follow-link ()
  "Follow the link under point."
  (interactive)
  (when-let ((title (clue--link-title-at-point))
             (loc (alist-get title clue--location-alist
                             nil nil #'equal)))
    (clue--goto-location loc)
    (pulse-momentary-highlight-one-line (point))))

;;;###autoload
(define-minor-mode clue-mode
  "Connect your clues in code reading."
  :lighter " Clue"
  (cond
   (clue-mode
    (jit-lock-register #'clue--refontify))
   (t
    (jit-lock-unregister #'clue--refontify)
    (save-restriction
      (widen)
      (clue--unfontify (point-min) (point-max))))))

(provide 'clue)

;; Local Variables:
;; outline-regexp: ";;;;* "
;; indent-tabs-mode: nil
;; fill-column: 79
;; emacs-lisp-docstring-fill-column: 65
;; sentence-end-double-space: t
;; End:

;;; clue.el ends here
